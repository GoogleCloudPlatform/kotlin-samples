//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: google/pubsub/v1/pubsub.proto

package com.google.pubsub.v1;

@kotlin.jvm.JvmSynthetic
inline fun subscription(block: com.google.pubsub.v1.SubscriptionKt.Dsl.() -> Unit): com.google.pubsub.v1.Subscription =
  com.google.pubsub.v1.SubscriptionKt.Dsl._create(com.google.pubsub.v1.Subscription.newBuilder()).apply { block() }._build()
object SubscriptionKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  class Dsl private constructor(
    @kotlin.jvm.JvmField private val _builder: com.google.pubsub.v1.Subscription.Builder
  ) {
    companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: com.google.pubsub.v1.Subscription.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): com.google.pubsub.v1.Subscription = _builder.build()

    /**
     * <pre>
     * Required. The name of the subscription. It must have the format
     * `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
     * start with a letter, and contain only letters (`[A-Za-z]`), numbers
     * (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
     * plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
     * in length, and it must not start with `"goog"`.
     * </pre>
     *
     * <code>string name = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    var name: kotlin.String
      @JvmName("getName")
      get() = _builder.getName()
      @JvmName("setName")
      set(value) {
        _builder.setName(value)
      }
    /**
     * <pre>
     * Required. The name of the subscription. It must have the format
     * `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
     * start with a letter, and contain only letters (`[A-Za-z]`), numbers
     * (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
     * plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
     * in length, and it must not start with `"goog"`.
     * </pre>
     *
     * <code>string name = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    fun clearName() {
      _builder.clearName()
    }

    /**
     * <pre>
     * Required. The name of the topic from which this subscription is receiving
     * messages. Format is `projects/{project}/topics/{topic}`. The value of this
     * field will be `_deleted-topic_` if the topic has been deleted.
     * </pre>
     *
     * <code>string topic = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = { ... }</code>
     */
    var topic: kotlin.String
      @JvmName("getTopic")
      get() = _builder.getTopic()
      @JvmName("setTopic")
      set(value) {
        _builder.setTopic(value)
      }
    /**
     * <pre>
     * Required. The name of the topic from which this subscription is receiving
     * messages. Format is `projects/{project}/topics/{topic}`. The value of this
     * field will be `_deleted-topic_` if the topic has been deleted.
     * </pre>
     *
     * <code>string topic = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = { ... }</code>
     */
    fun clearTopic() {
      _builder.clearTopic()
    }

    /**
     * <pre>
     * If push delivery is used with this subscription, this field is
     * used to configure it. An empty `pushConfig` signifies that the subscriber
     * will pull and ack messages using API methods.
     * </pre>
     *
     * <code>.google.pubsub.v1.PushConfig push_config = 4;</code>
     */
    var pushConfig: com.google.pubsub.v1.PushConfig
      @JvmName("getPushConfig")
      get() = _builder.getPushConfig()
      @JvmName("setPushConfig")
      set(value) {
        _builder.setPushConfig(value)
      }
    /**
     * <pre>
     * If push delivery is used with this subscription, this field is
     * used to configure it. An empty `pushConfig` signifies that the subscriber
     * will pull and ack messages using API methods.
     * </pre>
     *
     * <code>.google.pubsub.v1.PushConfig push_config = 4;</code>
     */
    fun clearPushConfig() {
      _builder.clearPushConfig()
    }
    /**
     * <pre>
     * If push delivery is used with this subscription, this field is
     * used to configure it. An empty `pushConfig` signifies that the subscriber
     * will pull and ack messages using API methods.
     * </pre>
     *
     * <code>.google.pubsub.v1.PushConfig push_config = 4;</code>
     * @return Whether the pushConfig field is set.
     */
    fun hasPushConfig(): kotlin.Boolean {
      return _builder.hasPushConfig()
    }

    /**
     * <pre>
     * The approximate amount of time (on a best-effort basis) Pub/Sub waits for
     * the subscriber to acknowledge receipt before resending the message. In the
     * interval after the message is delivered and before it is acknowledged, it
     * is considered to be &lt;i&gt;outstanding&lt;/i&gt;. During that time period, the
     * message will not be redelivered (on a best-effort basis).
     * For pull subscriptions, this value is used as the initial value for the ack
     * deadline. To override this value for a given message, call
     * `ModifyAckDeadline` with the corresponding `ack_id` if using
     * non-streaming pull or send the `ack_id` in a
     * `StreamingModifyAckDeadlineRequest` if using streaming pull.
     * The minimum custom deadline you can specify is 10 seconds.
     * The maximum custom deadline you can specify is 600 seconds (10 minutes).
     * If this parameter is 0, a default value of 10 seconds is used.
     * For push delivery, this value is also used to set the request timeout for
     * the call to the push endpoint.
     * If the subscriber never acknowledges the message, the Pub/Sub
     * system will eventually redeliver the message.
     * </pre>
     *
     * <code>int32 ack_deadline_seconds = 5;</code>
     */
    var ackDeadlineSeconds: kotlin.Int
      @JvmName("getAckDeadlineSeconds")
      get() = _builder.getAckDeadlineSeconds()
      @JvmName("setAckDeadlineSeconds")
      set(value) {
        _builder.setAckDeadlineSeconds(value)
      }
    /**
     * <pre>
     * The approximate amount of time (on a best-effort basis) Pub/Sub waits for
     * the subscriber to acknowledge receipt before resending the message. In the
     * interval after the message is delivered and before it is acknowledged, it
     * is considered to be &lt;i&gt;outstanding&lt;/i&gt;. During that time period, the
     * message will not be redelivered (on a best-effort basis).
     * For pull subscriptions, this value is used as the initial value for the ack
     * deadline. To override this value for a given message, call
     * `ModifyAckDeadline` with the corresponding `ack_id` if using
     * non-streaming pull or send the `ack_id` in a
     * `StreamingModifyAckDeadlineRequest` if using streaming pull.
     * The minimum custom deadline you can specify is 10 seconds.
     * The maximum custom deadline you can specify is 600 seconds (10 minutes).
     * If this parameter is 0, a default value of 10 seconds is used.
     * For push delivery, this value is also used to set the request timeout for
     * the call to the push endpoint.
     * If the subscriber never acknowledges the message, the Pub/Sub
     * system will eventually redeliver the message.
     * </pre>
     *
     * <code>int32 ack_deadline_seconds = 5;</code>
     */
    fun clearAckDeadlineSeconds() {
      _builder.clearAckDeadlineSeconds()
    }

    /**
     * <pre>
     * Indicates whether to retain acknowledged messages. If true, then
     * messages are not expunged from the subscription's backlog, even if they are
     * acknowledged, until they fall out of the `message_retention_duration`
     * window. This must be true if you would like to [Seek to a timestamp]
     * (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time).
     * </pre>
     *
     * <code>bool retain_acked_messages = 7;</code>
     */
    var retainAckedMessages: kotlin.Boolean
      @JvmName("getRetainAckedMessages")
      get() = _builder.getRetainAckedMessages()
      @JvmName("setRetainAckedMessages")
      set(value) {
        _builder.setRetainAckedMessages(value)
      }
    /**
     * <pre>
     * Indicates whether to retain acknowledged messages. If true, then
     * messages are not expunged from the subscription's backlog, even if they are
     * acknowledged, until they fall out of the `message_retention_duration`
     * window. This must be true if you would like to [Seek to a timestamp]
     * (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time).
     * </pre>
     *
     * <code>bool retain_acked_messages = 7;</code>
     */
    fun clearRetainAckedMessages() {
      _builder.clearRetainAckedMessages()
    }

    /**
     * <pre>
     * How long to retain unacknowledged messages in the subscription's backlog,
     * from the moment a message is published.
     * If `retain_acked_messages` is true, then this also configures the retention
     * of acknowledged messages, and thus configures how far back in time a `Seek`
     * can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10
     * minutes.
     * </pre>
     *
     * <code>.google.protobuf.Duration message_retention_duration = 8;</code>
     */
    var messageRetentionDuration: com.google.protobuf.Duration
      @JvmName("getMessageRetentionDuration")
      get() = _builder.getMessageRetentionDuration()
      @JvmName("setMessageRetentionDuration")
      set(value) {
        _builder.setMessageRetentionDuration(value)
      }
    /**
     * <pre>
     * How long to retain unacknowledged messages in the subscription's backlog,
     * from the moment a message is published.
     * If `retain_acked_messages` is true, then this also configures the retention
     * of acknowledged messages, and thus configures how far back in time a `Seek`
     * can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10
     * minutes.
     * </pre>
     *
     * <code>.google.protobuf.Duration message_retention_duration = 8;</code>
     */
    fun clearMessageRetentionDuration() {
      _builder.clearMessageRetentionDuration()
    }
    /**
     * <pre>
     * How long to retain unacknowledged messages in the subscription's backlog,
     * from the moment a message is published.
     * If `retain_acked_messages` is true, then this also configures the retention
     * of acknowledged messages, and thus configures how far back in time a `Seek`
     * can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10
     * minutes.
     * </pre>
     *
     * <code>.google.protobuf.Duration message_retention_duration = 8;</code>
     * @return Whether the messageRetentionDuration field is set.
     */
    fun hasMessageRetentionDuration(): kotlin.Boolean {
      return _builder.hasMessageRetentionDuration()
    }

    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    class LabelsProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * <pre>
     * See &lt;a href="https://cloud.google.com/pubsub/docs/labels"&gt; Creating and
     * managing labels&lt;/a&gt;.
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 9;</code>
     */
     val labels: com.google.protobuf.kotlin.DslMap<kotlin.String, kotlin.String, LabelsProxy>
      @kotlin.jvm.JvmSynthetic
      @JvmName("getLabelsMap")
      get() = com.google.protobuf.kotlin.DslMap(
        _builder.getLabelsMap()
      )
    /**
     * <pre>
     * See &lt;a href="https://cloud.google.com/pubsub/docs/labels"&gt; Creating and
     * managing labels&lt;/a&gt;.
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 9;</code>
     */
    @JvmName("putLabels")
    fun com.google.protobuf.kotlin.DslMap<kotlin.String, kotlin.String, LabelsProxy>
      .put(key: kotlin.String, value: kotlin.String) {
         _builder.putLabels(key, value)
       }
    /**
     * <pre>
     * See &lt;a href="https://cloud.google.com/pubsub/docs/labels"&gt; Creating and
     * managing labels&lt;/a&gt;.
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 9;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("setLabels")
    inline operator fun com.google.protobuf.kotlin.DslMap<kotlin.String, kotlin.String, LabelsProxy>
      .set(key: kotlin.String, value: kotlin.String) {
         put(key, value)
       }
    /**
     * <pre>
     * See &lt;a href="https://cloud.google.com/pubsub/docs/labels"&gt; Creating and
     * managing labels&lt;/a&gt;.
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 9;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("removeLabels")
    fun com.google.protobuf.kotlin.DslMap<kotlin.String, kotlin.String, LabelsProxy>
      .remove(key: kotlin.String) {
         _builder.removeLabels(key)
       }
    /**
     * <pre>
     * See &lt;a href="https://cloud.google.com/pubsub/docs/labels"&gt; Creating and
     * managing labels&lt;/a&gt;.
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 9;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("putAllLabels")
    fun com.google.protobuf.kotlin.DslMap<kotlin.String, kotlin.String, LabelsProxy>
      .putAll(map: kotlin.collections.Map<kotlin.String, kotlin.String>) {
         _builder.putAllLabels(map)
       }
    /**
     * <pre>
     * See &lt;a href="https://cloud.google.com/pubsub/docs/labels"&gt; Creating and
     * managing labels&lt;/a&gt;.
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 9;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("clearLabels")
    fun com.google.protobuf.kotlin.DslMap<kotlin.String, kotlin.String, LabelsProxy>
      .clear() {
         _builder.clearLabels()
       }

    /**
     * <pre>
     * If true, messages published with the same `ordering_key` in `PubsubMessage`
     * will be delivered to the subscribers in the order in which they
     * are received by the Pub/Sub system. Otherwise, they may be delivered in
     * any order.
     * </pre>
     *
     * <code>bool enable_message_ordering = 10;</code>
     */
    var enableMessageOrdering: kotlin.Boolean
      @JvmName("getEnableMessageOrdering")
      get() = _builder.getEnableMessageOrdering()
      @JvmName("setEnableMessageOrdering")
      set(value) {
        _builder.setEnableMessageOrdering(value)
      }
    /**
     * <pre>
     * If true, messages published with the same `ordering_key` in `PubsubMessage`
     * will be delivered to the subscribers in the order in which they
     * are received by the Pub/Sub system. Otherwise, they may be delivered in
     * any order.
     * </pre>
     *
     * <code>bool enable_message_ordering = 10;</code>
     */
    fun clearEnableMessageOrdering() {
      _builder.clearEnableMessageOrdering()
    }

    /**
     * <pre>
     * A policy that specifies the conditions for this subscription's expiration.
     * A subscription is considered active as long as any connected subscriber is
     * successfully consuming messages from the subscription or is issuing
     * operations on the subscription. If `expiration_policy` is not set, a
     * *default policy* with `ttl` of 31 days will be used. The minimum allowed
     * value for `expiration_policy.ttl` is 1 day.
     * </pre>
     *
     * <code>.google.pubsub.v1.ExpirationPolicy expiration_policy = 11;</code>
     */
    var expirationPolicy: com.google.pubsub.v1.ExpirationPolicy
      @JvmName("getExpirationPolicy")
      get() = _builder.getExpirationPolicy()
      @JvmName("setExpirationPolicy")
      set(value) {
        _builder.setExpirationPolicy(value)
      }
    /**
     * <pre>
     * A policy that specifies the conditions for this subscription's expiration.
     * A subscription is considered active as long as any connected subscriber is
     * successfully consuming messages from the subscription or is issuing
     * operations on the subscription. If `expiration_policy` is not set, a
     * *default policy* with `ttl` of 31 days will be used. The minimum allowed
     * value for `expiration_policy.ttl` is 1 day.
     * </pre>
     *
     * <code>.google.pubsub.v1.ExpirationPolicy expiration_policy = 11;</code>
     */
    fun clearExpirationPolicy() {
      _builder.clearExpirationPolicy()
    }
    /**
     * <pre>
     * A policy that specifies the conditions for this subscription's expiration.
     * A subscription is considered active as long as any connected subscriber is
     * successfully consuming messages from the subscription or is issuing
     * operations on the subscription. If `expiration_policy` is not set, a
     * *default policy* with `ttl` of 31 days will be used. The minimum allowed
     * value for `expiration_policy.ttl` is 1 day.
     * </pre>
     *
     * <code>.google.pubsub.v1.ExpirationPolicy expiration_policy = 11;</code>
     * @return Whether the expirationPolicy field is set.
     */
    fun hasExpirationPolicy(): kotlin.Boolean {
      return _builder.hasExpirationPolicy()
    }

    /**
     * <pre>
     * An expression written in the Pub/Sub [filter
     * language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
     * then only `PubsubMessage`s whose `attributes` field matches the filter are
     * delivered on this subscription. If empty, then no messages are filtered
     * out.
     * </pre>
     *
     * <code>string filter = 12;</code>
     */
    var filter: kotlin.String
      @JvmName("getFilter")
      get() = _builder.getFilter()
      @JvmName("setFilter")
      set(value) {
        _builder.setFilter(value)
      }
    /**
     * <pre>
     * An expression written in the Pub/Sub [filter
     * language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
     * then only `PubsubMessage`s whose `attributes` field matches the filter are
     * delivered on this subscription. If empty, then no messages are filtered
     * out.
     * </pre>
     *
     * <code>string filter = 12;</code>
     */
    fun clearFilter() {
      _builder.clearFilter()
    }

    /**
     * <pre>
     * A policy that specifies the conditions for dead lettering messages in
     * this subscription. If dead_letter_policy is not set, dead lettering
     * is disabled.
     * The Cloud Pub/Sub service account associated with this subscriptions's
     * parent project (i.e.,
     * service-{project_number}&#64;gcp-sa-pubsub.iam.gserviceaccount.com) must have
     * permission to Acknowledge() messages on this subscription.
     * </pre>
     *
     * <code>.google.pubsub.v1.DeadLetterPolicy dead_letter_policy = 13;</code>
     */
    var deadLetterPolicy: com.google.pubsub.v1.DeadLetterPolicy
      @JvmName("getDeadLetterPolicy")
      get() = _builder.getDeadLetterPolicy()
      @JvmName("setDeadLetterPolicy")
      set(value) {
        _builder.setDeadLetterPolicy(value)
      }
    /**
     * <pre>
     * A policy that specifies the conditions for dead lettering messages in
     * this subscription. If dead_letter_policy is not set, dead lettering
     * is disabled.
     * The Cloud Pub/Sub service account associated with this subscriptions's
     * parent project (i.e.,
     * service-{project_number}&#64;gcp-sa-pubsub.iam.gserviceaccount.com) must have
     * permission to Acknowledge() messages on this subscription.
     * </pre>
     *
     * <code>.google.pubsub.v1.DeadLetterPolicy dead_letter_policy = 13;</code>
     */
    fun clearDeadLetterPolicy() {
      _builder.clearDeadLetterPolicy()
    }
    /**
     * <pre>
     * A policy that specifies the conditions for dead lettering messages in
     * this subscription. If dead_letter_policy is not set, dead lettering
     * is disabled.
     * The Cloud Pub/Sub service account associated with this subscriptions's
     * parent project (i.e.,
     * service-{project_number}&#64;gcp-sa-pubsub.iam.gserviceaccount.com) must have
     * permission to Acknowledge() messages on this subscription.
     * </pre>
     *
     * <code>.google.pubsub.v1.DeadLetterPolicy dead_letter_policy = 13;</code>
     * @return Whether the deadLetterPolicy field is set.
     */
    fun hasDeadLetterPolicy(): kotlin.Boolean {
      return _builder.hasDeadLetterPolicy()
    }

    /**
     * <pre>
     * A policy that specifies how Pub/Sub retries message delivery for this
     * subscription.
     * If not set, the default retry policy is applied. This generally implies
     * that messages will be retried as soon as possible for healthy subscribers.
     * RetryPolicy will be triggered on NACKs or acknowledgement deadline
     * exceeded events for a given message.
     * </pre>
     *
     * <code>.google.pubsub.v1.RetryPolicy retry_policy = 14;</code>
     */
    var retryPolicy: com.google.pubsub.v1.RetryPolicy
      @JvmName("getRetryPolicy")
      get() = _builder.getRetryPolicy()
      @JvmName("setRetryPolicy")
      set(value) {
        _builder.setRetryPolicy(value)
      }
    /**
     * <pre>
     * A policy that specifies how Pub/Sub retries message delivery for this
     * subscription.
     * If not set, the default retry policy is applied. This generally implies
     * that messages will be retried as soon as possible for healthy subscribers.
     * RetryPolicy will be triggered on NACKs or acknowledgement deadline
     * exceeded events for a given message.
     * </pre>
     *
     * <code>.google.pubsub.v1.RetryPolicy retry_policy = 14;</code>
     */
    fun clearRetryPolicy() {
      _builder.clearRetryPolicy()
    }
    /**
     * <pre>
     * A policy that specifies how Pub/Sub retries message delivery for this
     * subscription.
     * If not set, the default retry policy is applied. This generally implies
     * that messages will be retried as soon as possible for healthy subscribers.
     * RetryPolicy will be triggered on NACKs or acknowledgement deadline
     * exceeded events for a given message.
     * </pre>
     *
     * <code>.google.pubsub.v1.RetryPolicy retry_policy = 14;</code>
     * @return Whether the retryPolicy field is set.
     */
    fun hasRetryPolicy(): kotlin.Boolean {
      return _builder.hasRetryPolicy()
    }

    /**
     * <pre>
     * Indicates whether the subscription is detached from its topic. Detached
     * subscriptions don't receive messages from their topic and don't retain any
     * backlog. `Pull` and `StreamingPull` requests will return
     * FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
     * the endpoint will not be made.
     * </pre>
     *
     * <code>bool detached = 15;</code>
     */
    var detached: kotlin.Boolean
      @JvmName("getDetached")
      get() = _builder.getDetached()
      @JvmName("setDetached")
      set(value) {
        _builder.setDetached(value)
      }
    /**
     * <pre>
     * Indicates whether the subscription is detached from its topic. Detached
     * subscriptions don't receive messages from their topic and don't retain any
     * backlog. `Pull` and `StreamingPull` requests will return
     * FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
     * the endpoint will not be made.
     * </pre>
     *
     * <code>bool detached = 15;</code>
     */
    fun clearDetached() {
      _builder.clearDetached()
    }
  }
}
@kotlin.jvm.JvmSynthetic
inline fun com.google.pubsub.v1.Subscription.copy(block: com.google.pubsub.v1.SubscriptionKt.Dsl.() -> Unit): com.google.pubsub.v1.Subscription =
  com.google.pubsub.v1.SubscriptionKt.Dsl._create(this.toBuilder()).apply { block() }._build()
